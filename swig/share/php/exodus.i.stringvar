%module(docstring="An interface to Exodus") exodus

%include <swig.swg>

#ifdef SWIGCSHARP
//if you change "mvar" then it also need to be changed in build scripts prebuildcsharp.cmd and config.sh
//(until exodus.i somehow implements "override" keyword on mvar ToString)
%rename(mvar) var;
%include "csharp/csharp.swg"
%include "csharp/std_wstring.i"
%include "csharp/std_string.i" 
%include "csharp/typemaps.i"
%include "csharp/wchar.i"
%include "exception.i"
%include <std_string.i>

%ignore exodus::var::var(wchar_t const *);
%ignore exodus::var::var(char const *);

//prebuildcsharp.cmd adds OVERRIDE replce "public string ToString" with "public override string ToString"
%rename (ToString) toString;
#endif

#ifdef SWIGJAVA
%include "java/java.swg"
%include "java/javakw.swg"
%include "java/typemaps.i"
%include "java/std_wstring.i"
%include "java/std_string.i" 
%include "php/utils.i"
%include "exception.i"
%include <std_string.i>
//%rename (tostring) toString;
#endif

#ifdef SWIGPYTHON

%implicitconv var;
%include "python/pywstrings.swg"
%include "python/pystrings.swg"
%include "python/std_string.i"
%include "python/typemaps.i"

%fragment("SWIG_AsVal_wchar_t", "header", fragment="<wchar.h>") {
    SWIGINTERN int SWIG_AsVal_wchar_t(PyObject* p, wchar_t* c) {
        return SWIG_OK;
    }
}
%fragment("SWIG_From_wchar_t", "header", fragment="<wchar.h>") {
    SWIGINTERNINLINE PyObject* SWIG_From_wchar_t(wchar_t c) {
        return SWIG_Py_Void();
    }
} 

/*
// Python -> C
%typemap(in) wchar_t const * {
  $1 = PyString_to_wchar_t($input);
}

// C -> Python
%typemap(out) wchar_t * {
  $result = wchar_t_to_PyObject($1);
}
*/

//%rename(__repr__) toString;
%rename(__str__) toString;
%rename(__int__) toInt;

//not necessary? since __nonzero__ is automatic from exodus var operator bool
//%rename(__nonzero__) toBool;

#endif

#ifdef SWIGPHP
%include "php/php.swg"

//%include "php/phpinit.swg"
//%include "php/phprun.swg"
//%include "php/phpkw.swg"

%include "php/typemaps.i"
%include "php/std_string.i"

%include "exception.i"
%include "php/utils.i"

%rename(mvar) var;
%rename(__toString) toString;

#endif

#ifdef SWIGPERL

%include <typemaps/implicit.swg>
%include <perl5.swg>
%include <typemaps.i>
%include <std_string.i>
//%include <std_wstring.i>
%include <wchar.i>

//http://perldoc.perl.org/overload.html

//swig interface is currently converting undefined var to string in some cases
//for now, return "" in that case




/*
%include "perl5/attribute.i"
%include "perl5/carrays.i"
%include "perl5/cdata.i"
%include "perl5/cmalloc.i"
//%include "perl5/cni.i"
%include "perl5/cpointer.i"
%include "perl5/cstring.i"
%include "perl5/exception.i"
%include "perl5/factory.i"
%include "perl5/jstring.i"
//%include "perl5/Makefile.pl"
//%include "perl5/noembed.h"
%include "perl5/perl5.swg"
//%include "perl5/perlerrors.swg"
%include "perl5/perlfragments.swg"
%include "perl5/perlhead.swg"
%include "perl5/perlinit.swg"
%include "perl5/perlkw.swg"
%include "perl5/perlmacros.swg"
%include "perl5/perlmain.i"
%include "perl5/perlopers.swg"
%include "perl5/perlprimtypes.swg"
//%include "perl5/perlrun.swg"
%include "perl5/perlruntime.swg"
%include "perl5/perlstrings.swg"
%include "perl5/perltypemaps.swg"
%include "perl5/perluserdir.swg"
%include "perl5/reference.i"
%include "perl5/std_common.i"
%include "perl5/std_deque.i"
%include "perl5/std_except.i"
%include "perl5/std_list.i"
%include "perl5/std_map.i"
%include "perl5/std_pair.i"
%include "perl5/std_string.i"
%include "perl5/std_vector.i"
%include "perl5/stl.i"
%include "perl5/typemaps.i"
*/

%rename(__str__) toString2;

//linking of swig gets confused and wants var:win32_connect and var:win32_select?!
//solution seems to be to undefine some macros (from where) in top of mv.h during swig generation
//%rename (connect) connect_renamed;
//%rename (select) select_renamed;
//%rename (abort) abort_renamed;
//%implicitconv var;

%fragment("SWIG_AsVal_wchar_t", "header", fragment="<wchar.h>") {
    SWIGINTERN int SWIG_AsVal_wchar_t(PlObject* p, wchar_t* c) {
        return SWIG_OK;
    }
}
%fragment("SWIG_From_wchar_t", "header", fragment="<wchar.h>") {
    SWIGINTERNINLINE PlObject* SWIG_From_wchar_t(wchar_t c) {
        return SWIG_Pl_Void();
    }
} 

%fragment("SWIG_AsVal_char", "header", fragment="<char.h>") {
    SWIGINTERN int SWIG_AsVal_char(PlObject* p, char* c) {
        return SWIG_OK;
    }
}
%fragment("SWIG_From_char", "header", fragment="<char>") {
    SWIGINTERNINLINE PlObject* SWIG_From_char(char c) {
        return SWIG_Pl_Void();
    }
} 

#endif

//#define EXO_MVENVIRONMENT_CPP

%{
//#include "exodus/mvenvironment.h"
//#include "exodus/exodusfuncs.h"
//#include "exodus/exodusmacros.h"
#include "exodus/mv.h"
%}











/* -----------------------------------------------------------------------------
 * exodus_var.i
 *
 * SWIG typemaps for exodus::var types
 * ----------------------------------------------------------------------------- */

// ------------------------------------------------------------------------
// exodus::var is typemapped by value
// This can prevent exporting methods which return a string
// in order for the user to modify it.
// However, I think I'll wait until someone asks for it...
// ------------------------------------------------------------------------

%include <exception.i>

namespace exodus {

    %naturalvar var;

    class var;

    //%typemap(typecheck,precedence=SWIG_TYPECHECK_VAR) var, const var& %{
    //   $1 = ( Z_TYPE_PP($input) == IS_VAR ) ? 1 : 0;
    //%}

    %typemap(in) var %{
        convert_to_string_ex($input);
        //$1.assign(Z_STRVAL_PP($input), Z_STRLEN_PP($input));
	{
		exodus::var tempvar(Z_STRVAL_PP($input), Z_STRLEN_PP($input));
		$1=tempvar;
	}
    %}

/* this converts all vars returned by functions (not function arguments) to be converted to php strings
    %typemap(out) var %{
	{
		std::string tempstr($1.toString());
		ZVAL_STRINGL($result, const_cast<char*>(tempstr.data()), tempstr.size(), 1);
	}
    %}

    %typemap(out) const var & %{
	{
		std::string tempstr($1->toString());
		ZVAL_STRINGL($result, const_cast<char*>(tempstr.data()),tempstr.size(), 1);
	}
    %}
*/

    // These next two handle a function which takes a non-const reference to
    // a std::var and modifies the var.
    %typemap(in) var & (exodus::var temp) %{
        convert_to_string_ex($input);
        //temp.assign(Z_STRVAL_PP($input), Z_STRLEN_PP($input));
	{
		std::string tempstr(Z_STRVAL_PP($input), Z_STRLEN_PP($input));
		temp=tempstr;
	}
        $1 = &temp;
    %}

/* causes all var reference function ARGUMENTs to be converted to php strings on return
    %typemap(argout) var & %{
	{
		std::string tempstr=$1->toString();
		ZVAL_STRINGL(*($input), const_cast<char*>(tempstr.data()), tempstr.size(), 1);
	}
    %}

    //SWIG will apply the non-const typemap above to const var& without
    // this more specific typemap. 
    %typemap(argout) const var & "";
*/

/*
    %typemap(directorin) var, const var& %{
        ZVAL_STRINGL($input, const_cast<char*>($1_name.toString().data()), $1_name.toString().size(), 1);
    %}

    %typemap(directorout) var %{
        convert_to_string_ex($input);
        //$result.assign(Z_STRVAL_PP($input), Z_STRLEN_PP($input));
	{
		exodus::var tempvar(Z_STRVAL_PP($input), Z_STRLEN_PP($input));
		$result=tempvar;
	}
    %}

    %typemap(directorout) var & (exodus::var *temp) %{
        convert_to_string_ex($input);
	{
		std::string tempstr(Z_STRVAL_PP($input), Z_STRLEN_PP($input));
		temp = new exodus::var(tempstr);
	}
        swig_acquire_ownership(temp);
        $result = temp;
    %}
*/
    %typemap(throws) var, const var& %{
        zend_throw_exception(NULL, const_cast<char*>($1.toString().c_str()), 0 TSRMLS_CC);
        return;
    %}

}











//%include "exodus/mvenvironment.h"
//%include "exodus/exodusfuncs.h"
//%include "exodus/exodusmacros.h"
%include "exodus/mv.h"
