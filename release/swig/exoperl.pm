# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package exoperl;
use base qw(Exporter);
use base qw(DynaLoader);
package exoperlc;
bootstrap exoperl;
package exoperl;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package exoperl;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package exoperl;

*MVeq = *exoperlc::MVeq;
*MVlt = *exoperlc::MVlt;
*__eq__ = *exoperlc::__eq__;
*__ne__ = *exoperlc::__ne__;
*__lt__ = *exoperlc::__lt__;
*__ge__ = *exoperlc::__ge__;
*__gt__ = *exoperlc::__gt__;
*__le__ = *exoperlc::__le__;
*__not__ = *exoperlc::__not__;
*MVadd = *exoperlc::MVadd;
*MVmul = *exoperlc::MVmul;
*MVdiv = *exoperlc::MVdiv;
*MVmod = *exoperlc::MVmod;
*MVcat = *exoperlc::MVcat;
*__add__ = *exoperlc::__add__;
*__sub__ = *exoperlc::__sub__;
*__mul__ = *exoperlc::__mul__;
*__div__ = *exoperlc::__div__;
*__mod__ = *exoperlc::__mod__;
*__xor__ = *exoperlc::__xor__;
*__lshift__ = *exoperlc::__lshift__;
*output = *exoperlc::output;
*outputl = *exoperlc::outputl;
*outputt = *exoperlc::outputt;
*errput = *exoperlc::errput;
*errputl = *exoperlc::errputl;
*logput = *exoperlc::logput;
*logputl = *exoperlc::logputl;
*backtrace = *exoperlc::backtrace;
*getenvironmentn = *exoperlc::getenvironmentn;
*setenvironmentn = *exoperlc::setenvironmentn;
*getprocessn = *exoperlc::getprocessn;
*getexecpath = *exoperlc::getexecpath;

############# Class : exoperl::var ##############

package exoperl::var;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_var($self);
        delete $OWNER{$self};
    }
}

*toBool = *exoperlc::var_toBool;
*toInt = *exoperlc::var_toInt;
*toDouble = *exoperlc::var_toDouble;
*towstring = *exoperlc::var_towstring;
*tostring = *exoperlc::var_tostring;
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_var(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *exoperlc::var___call__;
*__plusplus__ = *exoperlc::var___plusplus__;
*__minmin__ = *exoperlc::var___minmin__;
*__iadd__ = *exoperlc::var___iadd__;
*__isub__ = *exoperlc::var___isub__;
*date = *exoperlc::var_date;
*time = *exoperlc::var_time;
*timedate = *exoperlc::var_timedate;
*ossleep = *exoperlc::var_ossleep;
*ostime = *exoperlc::var_ostime;
*osopen = *exoperlc::var_osopen;
*osbread = *exoperlc::var_osbread;
*osbwrite = *exoperlc::var_osbwrite;
*osclose = *exoperlc::var_osclose;
*oswrite = *exoperlc::var_oswrite;
*osdelete = *exoperlc::var_osdelete;
*osrename = *exoperlc::var_osrename;
*oscopy = *exoperlc::var_oscopy;
*oslist = *exoperlc::var_oslist;
*oslistf = *exoperlc::var_oslistf;
*oslistd = *exoperlc::var_oslistd;
*osfile = *exoperlc::var_osfile;
*osdir = *exoperlc::var_osdir;
*osmkdir = *exoperlc::var_osmkdir;
*osrmdir = *exoperlc::var_osrmdir;
*oscwd = *exoperlc::var_oscwd;
*osflush = *exoperlc::var_osflush;
*osread = *exoperlc::var_osread;
*suspend = *exoperlc::var_suspend;
*osshell = *exoperlc::var_osshell;
*osshellread = *exoperlc::var_osshellread;
*osshellwrite = *exoperlc::var_osshellwrite;
*osgetenv = *exoperlc::var_osgetenv;
*ossetenv = *exoperlc::var_ossetenv;
*stop = *exoperlc::var_stop;
*perform = *exoperlc::var_perform;
*execute = *exoperlc::var_execute;
*chain = *exoperlc::var_chain;
*logoff = *exoperlc::var_logoff;
*debug = *exoperlc::var_debug;
*breakon = *exoperlc::var_breakon;
*breakoff = *exoperlc::var_breakoff;
*output = *exoperlc::var_output;
*outputl = *exoperlc::var_outputl;
*outputt = *exoperlc::var_outputt;
*logput = *exoperlc::var_logput;
*logputl = *exoperlc::var_logputl;
*errput = *exoperlc::var_errput;
*errputl = *exoperlc::var_errputl;
*put = *exoperlc::var_put;
*at = *exoperlc::var_at;
*getcursor = *exoperlc::var_getcursor;
*setcursor = *exoperlc::var_setcursor;
*getprompt = *exoperlc::var_getprompt;
*setprompt = *exoperlc::var_setprompt;
*input = *exoperlc::var_input;
*eof = *exoperlc::var_eof;
*assigned = *exoperlc::var_assigned;
*unassigned = *exoperlc::var_unassigned;
*transfer = *exoperlc::var_transfer;
*exchange = *exoperlc::var_exchange;
*clone = *exoperlc::var_clone;
*abs = *exoperlc::var_abs;
*mod = *exoperlc::var_mod;
*pwr = *exoperlc::var_pwr;
*rnd = *exoperlc::var_rnd;
*initrnd = *exoperlc::var_initrnd;
*exp = *exoperlc::var_exp;
*sqrt = *exoperlc::var_sqrt;
*sin = *exoperlc::var_sin;
*cos = *exoperlc::var_cos;
*tan = *exoperlc::var_tan;
*atan = *exoperlc::var_atan;
*loge = *exoperlc::var_loge;
*integer = *exoperlc::var_integer;
*floor = *exoperlc::var_floor;
*round = *exoperlc::var_round;
*setxlocale = *exoperlc::var_setxlocale;
*getxlocale = *exoperlc::var_getxlocale;
*chr = *exoperlc::var_chr;
*str = *exoperlc::var_str;
*space = *exoperlc::var_space;
*match = *exoperlc::var_match;
*seq = *exoperlc::var_seq;
*dcount = *exoperlc::var_dcount;
*count = *exoperlc::var_count;
*length = *exoperlc::var_length;
*len = *exoperlc::var_len;
*data = *exoperlc::var_data;
*isnum = *exoperlc::var_isnum;
*isnum_old = *exoperlc::var_isnum_old;
*converter = *exoperlc::var_converter;
*swapper = *exoperlc::var_swapper;
*splicer = *exoperlc::var_splicer;
*quoter = *exoperlc::var_quoter;
*squoter = *exoperlc::var_squoter;
*unquoter = *exoperlc::var_unquoter;
*ucaser = *exoperlc::var_ucaser;
*lcaser = *exoperlc::var_lcaser;
*trimmer = *exoperlc::var_trimmer;
*trimmerf = *exoperlc::var_trimmerf;
*trimmerb = *exoperlc::var_trimmerb;
*fieldstorer = *exoperlc::var_fieldstorer;
*substrer = *exoperlc::var_substrer;
*convert = *exoperlc::var_convert;
*swap = *exoperlc::var_swap;
*splice = *exoperlc::var_splice;
*quote = *exoperlc::var_quote;
*squote = *exoperlc::var_squote;
*unquote = *exoperlc::var_unquote;
*ucase = *exoperlc::var_ucase;
*lcase = *exoperlc::var_lcase;
*trim = *exoperlc::var_trim;
*trimf = *exoperlc::var_trimf;
*trimb = *exoperlc::var_trimb;
*fieldstore = *exoperlc::var_fieldstore;
*substr = *exoperlc::var_substr;
*index = *exoperlc::var_index;
*index2 = *exoperlc::var_index2;
*field = *exoperlc::var_field;
*field2 = *exoperlc::var_field2;
*oconv = *exoperlc::var_oconv;
*iconv = *exoperlc::var_iconv;
*lower = *exoperlc::var_lower;
*raise = *exoperlc::var_raise;
*crop = *exoperlc::var_crop;
*lowerer = *exoperlc::var_lowerer;
*raiser = *exoperlc::var_raiser;
*cropper = *exoperlc::var_cropper;
*remove = *exoperlc::var_remove;
*replace = *exoperlc::var_replace;
*insert = *exoperlc::var_insert;
*erase = *exoperlc::var_erase;
*extract = *exoperlc::var_extract;
*replacer = *exoperlc::var_replacer;
*inserter = *exoperlc::var_inserter;
*eraser = *exoperlc::var_eraser;
*locate = *exoperlc::var_locate;
*locateby = *exoperlc::var_locateby;
*locateusing = *exoperlc::var_locateusing;
*sum = *exoperlc::var_sum;
*disconnect = *exoperlc::var_disconnect;
*setdefaultconnection = *exoperlc::var_setdefaultconnection;
*begintrans = *exoperlc::var_begintrans;
*rollbacktrans = *exoperlc::var_rollbacktrans;
*committrans = *exoperlc::var_committrans;
*createdb = *exoperlc::var_createdb;
*deletedb = *exoperlc::var_deletedb;
*createfile = *exoperlc::var_createfile;
*deletefile = *exoperlc::var_deletefile;
*clearfile = *exoperlc::var_clearfile;
*listfiles = *exoperlc::var_listfiles;
*createindex = *exoperlc::var_createindex;
*deleteindex = *exoperlc::var_deleteindex;
*listindexes = *exoperlc::var_listindexes;
*open = *exoperlc::var_open;
*close = *exoperlc::var_close;
*clearselect = *exoperlc::var_clearselect;
*readnext = *exoperlc::var_readnext;
*selectrecord = *exoperlc::var_selectrecord;
*readnextrecord = *exoperlc::var_readnextrecord;
*lock = *exoperlc::var_lock;
*unlock = *exoperlc::var_unlock;
*unlockall = *exoperlc::var_unlockall;
*read = *exoperlc::var_read;
*readv = *exoperlc::var_readv;
*write = *exoperlc::var_write;
*writev = *exoperlc::var_writev;
*deleterecord = *exoperlc::var_deleterecord;
*updaterecord = *exoperlc::var_updaterecord;
*insertrecord = *exoperlc::var_insertrecord;
*xlate = *exoperlc::var_xlate;
*sqlexec = *exoperlc::var_sqlexec;
*version = *exoperlc::var_version;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::dim ##############

package exoperl::dim;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl );
%OWNER = ();
%ITERATORS = ();
*redim = *exoperlc::dim_redim;
*unparse = *exoperlc::dim_unparse;
*__call__ = *exoperlc::dim___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_dim($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = exoperlc::new_dim(@_);
    bless $self, $pkg if defined($self);
}

*parse = *exoperlc::dim_parse;
*read = *exoperlc::dim_read;
*write = *exoperlc::dim_write;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVException ##############

package exoperl::MVException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVException(@_);
    bless $self, $pkg if defined($self);
}

*swig_description_get = *exoperlc::MVException_description_get;
*swig_description_set = *exoperlc::MVException_description_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVDivideByZero ##############

package exoperl::MVDivideByZero;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVDivideByZero(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVDivideByZero($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVNonNumeric ##############

package exoperl::MVNonNumeric;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVNonNumeric(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVNonNumeric($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVOutOfMemory ##############

package exoperl::MVOutOfMemory;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVOutOfMemory(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVOutOfMemory($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVUnassigned ##############

package exoperl::MVUnassigned;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVUnassigned(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVUnassigned($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVUndefined ##############

package exoperl::MVUndefined;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVUndefined(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVUndefined($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVInvalidPointer ##############

package exoperl::MVInvalidPointer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVInvalidPointer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVInvalidPointer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVDBException ##############

package exoperl::MVDBException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVDBException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVDBException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVNotImplemented ##############

package exoperl::MVNotImplemented;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVNotImplemented(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVNotImplemented($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVDebug ##############

package exoperl::MVDebug;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVDebug(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVDebug($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVStop ##############

package exoperl::MVStop;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVStop(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVStop($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVAbort ##############

package exoperl::MVAbort;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVAbort(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVAbort($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVArrayDimensionedZero ##############

package exoperl::MVArrayDimensionedZero;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVArrayDimensionedZero(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVArrayDimensionedZero($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVArrayIndexOutOfBounds ##############

package exoperl::MVArrayIndexOutOfBounds;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVArrayIndexOutOfBounds(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVArrayIndexOutOfBounds($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : exoperl::MVArrayNotDimensioned ##############

package exoperl::MVArrayNotDimensioned;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( exoperl::MVException exoperl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = exoperlc::new_MVArrayNotDimensioned(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        exoperlc::delete_MVArrayNotDimensioned($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package exoperl;

*MV_H = *exoperlc::MV_H;
*mvtypemask = *exoperlc::mvtypemask;
*LASTDELIMITERCHARNOPLUS1 = *exoperlc::LASTDELIMITERCHARNOPLUS1;

my %__FM_hash;
tie %__FM_hash,"exoperl::var", $exoperlc::FM;
$FM= \%__FM_hash;
bless $FM, exoperl::var;

my %__VM_hash;
tie %__VM_hash,"exoperl::var", $exoperlc::VM;
$VM= \%__VM_hash;
bless $VM, exoperl::var;

my %__SM_hash;
tie %__SM_hash,"exoperl::var", $exoperlc::SM;
$SM= \%__SM_hash;
bless $SM, exoperl::var;

my %__SVM_hash;
tie %__SVM_hash,"exoperl::var", $exoperlc::SVM;
$SVM= \%__SVM_hash;
bless $SVM, exoperl::var;

my %__TM_hash;
tie %__TM_hash,"exoperl::var", $exoperlc::TM;
$TM= \%__TM_hash;
bless $TM, exoperl::var;

my %__STM_hash;
tie %__STM_hash,"exoperl::var", $exoperlc::STM;
$STM= \%__STM_hash;
bless $STM, exoperl::var;

my %__SSTM_hash;
tie %__SSTM_hash,"exoperl::var", $exoperlc::SSTM;
$SSTM= \%__SSTM_hash;
bless $SSTM, exoperl::var;

my %__IM_hash;
tie %__IM_hash,"exoperl::var", $exoperlc::IM;
$IM= \%__IM_hash;
bless $IM, exoperl::var;

my %__RM_hash;
tie %__RM_hash,"exoperl::var", $exoperlc::RM;
$RM= \%__RM_hash;
bless $RM, exoperl::var;

my %__AM_hash;
tie %__AM_hash,"exoperl::var", $exoperlc::AM;
$AM= \%__AM_hash;
bless $AM, exoperl::var;

my %__DQ_hash;
tie %__DQ_hash,"exoperl::var", $exoperlc::DQ;
$DQ= \%__DQ_hash;
bless $DQ, exoperl::var;

my %__SQ_hash;
tie %__SQ_hash,"exoperl::var", $exoperlc::SQ;
$SQ= \%__SQ_hash;
bless $SQ, exoperl::var;

my %__SLASH_hash;
tie %__SLASH_hash,"exoperl::var", $exoperlc::SLASH;
$SLASH= \%__SLASH_hash;
bless $SLASH, exoperl::var;
*SLASH_ = *exoperlc::SLASH_;
*SLASH_IS_BACKSLASH = *exoperlc::SLASH_IS_BACKSLASH;

my %__LOWERCASE__hash;
tie %__LOWERCASE__hash,"exoperl::var", $exoperlc::LOWERCASE_;
$LOWERCASE_= \%__LOWERCASE__hash;
bless $LOWERCASE_, exoperl::var;

my %__UPPERCASE__hash;
tie %__UPPERCASE__hash,"exoperl::var", $exoperlc::UPPERCASE_;
$UPPERCASE_= \%__UPPERCASE__hash;
bless $UPPERCASE_, exoperl::var;

my %__PLATFORM__hash;
tie %__PLATFORM__hash,"exoperl::var", $exoperlc::PLATFORM_;
$PLATFORM_= \%__PLATFORM__hash;
bless $PLATFORM_, exoperl::var;
*DBTRACE = *exoperlc::DBTRACE;

my %__EXECPATH2_hash;
tie %__EXECPATH2_hash,"exoperl::var", $exoperlc::EXECPATH2;
$EXECPATH2= \%__EXECPATH2_hash;
bless $EXECPATH2, exoperl::var;
1;
